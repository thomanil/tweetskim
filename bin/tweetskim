#!/usr/bin/env ruby

require "tweetskim"
require "optparse"


def parse_options
  options = {}

  OptionParser.new do |o|
    o.on("-a", "--show-all", "Show all tweets (max 300 tweets)") { |b| options[:show_all] = b }
    o.on("-e", "--mentions", "Show mentions instead of timeline") { |b| options[:mentions] = b }
    o.on("-i", "--inverse-order", "Inverse/reverse ordered tweets") { |b| options[:inverse_order] = b }
    o.on("-h", "--help", "Help page") { puts o; exit }
    o.on("-m", "--mark-all-read", "Mark everything up to now as read") { |b| options[:mark_all_read] = b }
    o.on("-n N", "--last-n-tweets N", "Show only the last N tweets") { |n| options[:tweet_no] = n }
    o.on("-o MODE", "--output-mode MODE", "Output as 'lines', 'column' or 'html'") { |mode| options[:output_mode] = mode }
    o.on("-u USER", "--user USER", "Which twitter user I am. Example: tweetskim -u thomanil") { |u| options[:user] = u }
    o.on("-v", "--version", "Spit out version") { |b| options[:version] = b }

    o.parse!
  end

  return options
end

def fetch_tweets(options = {})
  adapter = Tweetskim::TwitterAdapter.new
  tweets = adapter.timeline(:count => 100)
end

def write_tweets_to_stdout(tweets, options = {})
  formatter = Tweetskim::Formatter.new
  output_mode = options[:output_mode]

  if !output_mode || output_mode == "lines"
    result = formatter.lines(tweets, options)
  elsif output_mode == "column"
    result = formatter.column(tweets, {:width => 40})
  elsif output_mode == "html"
    raise "Not yet supported: html output mode"
  else
    puts "Invalid output mode."
    exit
  end
  
  puts result
end


options = parse_options
tweets = fetch_tweets(options)
write_tweets_to_stdout(tweets, options)
